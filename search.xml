<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019年终总结</title>
    <url>/blogs/ck50y9ml80002y12w1xn7f4h4/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><blockquote>
<p>这几天在家里忙于更新EdgeTranslate和做家务, 这篇2019年终总结写的有点晚了。</p>
</blockquote>
<h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾:"></a>回顾:</h4><h5 id="学业"><a href="#学业" class="headerlink" title="学业:"></a>学业:</h5><p>在2019年，在学习成绩上没有什么变化，在gpa上提升了1分，成绩已经很难有什么变化了。2019年主要的时间历程都是与留学申请相关。</p>
<h5 id="留学计划完成了申请部分"><a href="#留学计划完成了申请部分" class="headerlink" title="留学计划完成了申请部分"></a>留学计划完成了申请部分</h5><ul>
<li>考出了理想的托福成绩<br>在2019年2月23日，我第一次参加了托福考试，虽然只得了82分(阅读26 直接变成历史最佳)，但是这一成绩已经远远超出我的预期了，我刚开始以为只能得六七十分。这一成绩给了我很大的信心，由于当时母亲不支持我留学，所以这一成绩也让她得以支持我继续提高托福成绩。如果这次考试只有六十多分的话，估计留学计划就要夭折了。<br>在5月26日，我参加了第二次托福考试，这次我做了大量的听力练习，几乎听遍了TPO的题目，还在写作和口语方面做了些准备，所以在这次考试中得了94分，每科都是历史最佳。这次考试非常重要，这个成绩已经可以保证我能够有排名还可以接受的学校申请了，在与母亲的多次交谈后，她终于开始同意留学了，但还是同她做了一些妥协，不再申请香港了，改而决定去美国或澳大利亚，因为她觉得香港只有一年，时间太短，学不到有用的东西。<br>在7月7日还有一次托福考试，但是这场是和5月26日考试同时报的，是在学校课程结束后一周就考的，考前没有时间准备，相当于一次裸考，于是成绩就退回到了85分，浪费了一次机会。由于要准备美国的申请，就需要再考GRE，我开始的留学计划中是没有GRE的考虑的，时间就开始非常紧张了。<br>在暑假我在哈尔滨看了同学推荐的<a href="http://www.tuqiliuxue.com/" target="_blank" rel="noopener">土气留学</a>，在价格上非常诱人，还支持全球的混合申请，与我的目标比较吻合。我还在北京看了两家中介，其中一家的中介费更是达到了10万元，还只是美国院校的申请，最后还是选择了土气留学。<br>暑假开始我就转而学习GRE了，背单词过程一直不顺利，中间还要准备海量的材料，耽误了很多进度。在开学后我才发现哈尔滨没有GRE考位了，为了在申请前考出成绩，我就报了南昌大学10月20日的考试。由于不断有准备材料的事情打断，复习GRE的过程一直断断续续，效果不佳，在南昌没能考出320分。<br>10月28日从南昌回来后我又立马开始准备11月10日的托福考试，这次依然是主攻听力，听了微臣教育琦叔的听力课程，感觉他的方法非常适用，仿佛掌握了ETS的听力出题思路，最终在11月的托福考试中听力30分，总分98，拼分达到了102分，达到了理想的成绩。<br>之后由于有一个毕设开题，再次耽误GRE复习，在11月23日黑大的GRE考试中，考的比上次GRE还低，最终放弃再考GRE。<br>回顾托福GRE的备考，托福投入的时间最多，最终也如愿以偿，而GRE的备考和申请过程有冲突，没能达到目标。语言的提升，只有下功夫，就能达到目标。</li>
<li><p>完成了复杂的申请过程<br>申请除了准备托福GRE，还有很多的材料要准备，我从7月份签订了留学中介后，就开始了准备过程。<br>以下是一个材料清单：</p>
<ul>
<li>出生公证</li>
<li>户口公证</li>
<li>成绩公证 </li>
<li>排名公证</li>
<li>‌在读公证</li>
<li>护照</li>
<li>gre</li>
<li>托福</li>
<li>三封推荐信    </li>
<li>实习证明</li>
<li>奖项</li>
<li>cv(简历)</li>
<li><p>ps(个人陈述)   </p>
<p>每一个项准备起来都不轻松，尤其是三封推荐信，还需要和教授联系，还需要在规定时间内让教授自己在网站上提交推荐信，真的非常麻烦。<br>最终我在12月前完成了这些材料，并且提交了所有的申请。申请了六所的美国院校：UW, UCSD, UCI, UC-Davis, UW-Madison, USC<br>申请了5所澳洲大学：ANU, UMel, USydney, UNSW, UAdelaide<br>申请了1所加拿大院校：UBC</p>
</li>
</ul>
</li>
<li>offer<br>已经收到了UNSW, USydney, UAdelaide 这3所院校的offer，相信2020会收到更多吧，已经有学上了。</li>
</ul>
<h5 id="EdgeTranslate"><a href="#EdgeTranslate" class="headerlink" title="EdgeTranslate"></a>EdgeTranslate</h5><p>我和<a href="https://github.com/nickyc975" target="_blank" rel="noopener">室友</a>的合作项目: <a href="https://github.com/EdgeTranslate/EdgeTranslate" target="_blank" rel="noopener">EdgeTranslate</a>在2019年持续给人惊喜。截至目前，chrome商店的用户达到了1.1万，firefox商店的用户达到了2.2万，评价也都不错，除此之外，还有QQ浏览器和360浏览器，他们的用户量难以统计，从google analytics上的数据来看，最后日活有3万+，周活跃有5万用户，表现远远超过预期。<br>github的仓库有了将近300个star，这个也是远远超过了预期，用户反馈很活跃，给出的问题反馈和功能建议都很不错。<br>相信，这个项目我们以后会一直维护下去的。</p>
<h5 id="得奖情况"><a href="#得奖情况" class="headerlink" title="得奖情况"></a>得奖情况</h5><p>在2019年我参加的比赛不太多，但每个比赛都有收获，其中第二届微信小程序大赛我和同学们组队参加，成功进入了省决赛环节，最终得到了全国三等奖，得了1000元奖金。这是我大学阶段唯一一个国奖了。<br>在蓝桥杯java比赛中，我得了省二等奖，当天发挥不错，距离进入国赛就差了一名，感觉还是有点惋惜。<br>在2019年的美赛中，只得了一个s奖，感觉建的模型不错，可惜最后在写论文时非常仓促，格式也一团糟，这个结果也在意料之中。</p>
<h5 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h5><p>在2019年，我开始关注中西方的各方面差异，对制度，政治，金融有了不少认识，同时对留学计划进行了调整。<br>从小在学校接受各种所谓政治课程的教育，以及信息的获取来源的局限性，必然缺乏正确的世界观教育。这些都导致大部分人都认为自己的国家各方面都好的很，别的国家都不行，然而在成长过程中，我慢慢发现了很多与这些相悖的信息和事件，而且父母和身边人都避而不谈这些，或者说不敢谈论和深入了解这些。在初高中，我绝大部分时间都用来学习现在看来没什么卵用的应试教育内容，和大多数人一样对政治和经济等宏观的方面都不关注，直到大学后，我有了宽广的信息来源渠道，这些大量的悖论开始不断放大，我逐渐开始认真审视自己生存的环境，开始重塑世界观。<br>我开始发现历史书中从近代史开始，出现了很多经过精心修改或针对性误导的内容，尤其是建国后到改革开放前的历史，美化成果，略去灾难。从2018年修宪后，我开始发现某大会的本质，外表让人看起来都与西方的国会议会制度无异，但实质并非如此。尤其是2019年发生的像华为251事件，表现了司法制度的问题；民航医院医闹事件，表现了医疗制度的残缺；匹凸匹事件揭示了国资收割韭菜的实质以及群众表达诉求的无力……尤其是香港反送中事件后，更让人看清了大陆司法不独立的实质以及香港制度存在的严重隐患。<br>认清这些本质问题后，我开始放弃申请香港的大学。原本只是想在香港读完研后，回上海，杭州或深圳工作。现在我决定以后要到民主发达的国家定居。<br>主要有以下一些问题的考虑：</p>
<ul>
<li>其他国家完善的政治经济法律制度，三权分立制度带来的长期稳定性</li>
<li>其他国家让人放心的食品、空气质量(在北方生活，冬天的毒空气肯定让人折寿好多年)，高素质的人口(文明礼貌的行为让人舒适，我常常因为遇到的低素质行为而生闷气，尤其是公共场合吸烟)</li>
<li>教育可以让孩子避免洗脑教育和无意义的应试教育，可以不浪费时间在中文学习上</li>
<li>完善的医疗制度(加澳医疗免费，美国健全的医疗保险)</li>
<li>开方的言论和新闻自由，无需花精力研究如何稳定快速的帆樯</li>
<li>相对可以承受的房价(国内大部分的城市房价大量泡沫，北上广深买房无望，而且存在高位接盘，泡沫破裂债台高筑的隐患)，便宜的工业产品(个人喜欢汽车，电子产品和自动化的家具体验)</li>
<li>公民自由迁徙的权利(户口问题)</li>
<li>高度的国际化，与未来的发展趋势相符，一直有一个环球旅行的目标，免签更多的国家能带来更方便的旅行体验(免签可以还证明对一个国家人口素质的肯定)</li>
</ul>
<p>由此我了解了很多美加澳的移民政策，规划了几条路线:</p>
<ul>
<li>UBC-&gt;省提名/联邦通道</li>
<li>在澳留学-&gt;psw-&gt;1890(pr)/190(pr)/491-&gt;191(pr)</li>
<li>美国留学-&gt;psw-&gt;抽H1B-&gt;pr</li>
</ul>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望:"></a>展望:</h4><p>新年的目标: </p>
<ul>
<li>完成毕业论文，顺利毕业</li>
<li>根据offer情况和留学目标确定好院校</li>
<li>成功到学校就读</li>
<li>适应异国的学习和生活</li>
<li>快速提升英语口语水平</li>
<li>EdgeTranslate继续完善</li>
</ul>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语:"></a>结语:</h4><p>2019年我处于人生的十字路口，我最大的收获是成功的完成了大部分的留学计划，同时大幅度提高了自己的认知水平，看清了很多的本质，对今后几年有了比较清晰的规划，希望多年后的自己能够庆幸现在自己做出的重大决定。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>年终总结</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>java 集合类如何正确在迭代中添加删除元素</title>
    <url>/blogs/ck50y9mle0006y12wguyzcyx1/</url>
    <content><![CDATA[<p>刚开始尝试写博客不久，今天开创一个新的内容方向java,这是我的第一篇关于java的博客。<br>最近在完成java作业时，遇到了一个使用迭代器的问题。</p>
<p><font color="red">问题还原</font>：<br>遇到问题的代码过于复杂，我这里写了一个非常简单的反例，足以还原问题的原貌。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; number = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        number.addAll(Arrays.asList(<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (Integer i : number) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">5</span>)</span><br><span class="line">                number.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(number.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码目的是去掉ArrayList 类型的：   number中大于5的数字<br>报错结果是这样的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">        at java.util.LinkedList$ListItr.checkForComodification(LinkedList.java:<span class="number">966</span>)</span><br><span class="line">        at java.util.LinkedList$ListItr.next(LinkedList.java:<span class="number">888</span>)</span><br><span class="line">        at test.main(test.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<p>出行了这个 java.util.ConcurrentModificationException的异常。</p>
<p><font color="red">原因分析：</font><br>上面代码中我使用了Iterator迭代器，从而可以使用foreach语法实现遍历。Iterator是一个接口，Itr是一个实现这个接口的类，为了探究原因，最好查看一下迭代器的源码，在IDEA下，按住ctrl点击Itr，就看到了源码。<br>注意到在源码中，Itr的开头有一句<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure></p>
<p>也就是在类创建时，就将modCount赋值给了expectedModCount<br>然后在调用remove()这个函数的时候，都会调用一次内部的checkForComodification()函数<br>这个函数我摘录出来，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就得到了ConcurrentModificationException这个异常的来源，是因为modCount和expectedModCount不相等。<br>modCount是原来集合的版本号，每次修改(增、删)集合都会加1；expectedModCount是当前集合的版本号，当我在迭代过程中，删除了一个元素，原来集合的modCount就+1，而Itr迭代器实例是在迭代开始时创立的，expectedModCount并不会随着迭代过程发生改变，所以就会出现两个值不想等的情况。<br>除此之外，java这样检查的原因在于一个叫快速失败机制（fail-fast）<br>快速失败机制产生的条件:当多个线程对Collection进行操作时，若其中某一个线程通过Iterator遍历集合时，该集合的内容被其他线程所改变，则会抛出ConcurrentModificationException异常。<br>所以java这样检查为的是多线程数据处理的安全性。</p>
<p><font color="red">解决问题</font><br>由于在外部LinkedList本身删除或添加一个元素，在迭代器内部的expectedModCount没有跟着变化，所以就要使用迭代器自己提供的remove和add函数，这样迭代的expectedModCount就会同步变化，就不会报错。<br>修改后的代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; number = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        number.addAll(Arrays.asList(<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = number.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123; <span class="comment">// 判断是否还有下一个元素</span></span><br><span class="line">            <span class="keyword">int</span> i = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">5</span>)</span><br><span class="line">                <span class="comment">// 注意这里使用的是迭代器对象 iterator的remove,不是number的remove</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(number.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时，在java8中加入了函数式编程的一些语法，所以我用lamada表达式配合removeif函数来实现以上功能时，代码量会大大减小，这里一起分享一下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; number = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        number.addAll(Arrays.asList(<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        number.removeIf(num-&gt;num&gt;<span class="number">5</span>);  <span class="comment">// 这里的遍历和删除只有一短行就实现了</span></span><br><span class="line">        System.out.println(number.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体的lamda表达式生动解释，参见<a href="https://mp.weixin.qq.com/s/-PHOc6p-qKJBktle28AUgA" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>补充一点：上面的例子之所以用LinkedList，而不用List接口的另一个实现ArrayList类，是因为ArrayList的内部实现是依赖于数组的，数组本身不方便插入和删除，所以ArrayList类在实现接口函数remove时，直接抛出UnsupportedOperationException异常，也就是它不支持插入和删除，相比之下，LinkedList类是基于链表数据结构的实现，对于插入和删除就非常的简单和高效了。</p>
]]></content>
  </entry>
  <entry>
    <title>nginx+uwsgi部署实践的踩坑总结（一）</title>
    <url>/blogs/ck50y9mlg0008y12wtandf8ik/</url>
    <content><![CDATA[<font color="red">部署情景描述：</font>

<p>这周我的外包项目进入了部署阶段。这个项目采用了vue前端+django后端， vue前端打包成静态文件，通过nginx服务器负责vue静态文件请求的处理和反馈。django项目采用目前最普遍的uWSGI服务器运行，再通过nginx反向代理vue框架对后端的请求。<br>部署使用的服务器是阿里云ecs云服务器，配置是2核4G，1M带宽。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OS：Debian 9.2 stretch</span><br><span class="line">Kernel：x86_64 Linux 4.9.0-4-amd64</span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h5 id="1-nginx如何配置对前端vue资源的请求"><a href="#1-nginx如何配置对前端vue资源的请求" class="headerlink" title="1.nginx如何配置对前端vue资源的请求"></a>1.nginx如何配置对前端vue资源的请求</h5><p>如果前端vue没有使用服务端渲染的话，只需要将项目使用 npm run build  打包到一个 dist 文件夹下。可以通过 ftp，github等诸多方式将dist传到服务器上。我将这个dist文件夹放在了/home/temp/下。<br>如果 vue-router使用的是history模式（url里没有’#’这种符号），需要采用如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /&#123;</span><br><span class="line">	root /home/temp; <span class="comment"># my dist directory</span></span><br><span class="line">	index index.html;</span><br><span class="line">	try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html = 404;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置意思是  ：遇到没有匹配到的url，就在 dist文件夹里面 寻找index.html，如果有，就返回index.html(即前端页面), 如果没有，就返回404。</p>
<p>####2.第一次启动nginx显示80端口被占用</p>
<p>报错如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class="keyword">in</span> use)</span><br><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class="keyword">in</span> use)</span><br><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class="keyword">in</span> use)</span><br><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class="keyword">in</span> use)</span><br><span class="line">nginx: [emerg] <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class="keyword">in</span> use)</span><br><span class="line">nginx: [emerg] still could not <span class="built_in">bind</span>()</span><br></pre></td></tr></table></figure>
<hr>
<p>可以用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fuser -v -n tcp 80</span><br></pre></td></tr></table></figure>
<p>查看80端口的使用情况<br>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">80/tcp:              root      30148 F.... python</span><br></pre></td></tr></table></figure>
<hr>
<p>只要直接杀死占用端口的进程，就可以了，命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -s 9 pid #具体的pid值</span><br></pre></td></tr></table></figure></p>
<p>再次<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx start</span><br></pre></td></tr></table></figure></p>
<p>就不会报错了</p>
<hr>
<h5 id="3-nginx-配置正确，正常启动，但是在远程访问ip地址，-依旧无法访问"><a href="#3-nginx-配置正确，正常启动，但是在远程访问ip地址，-依旧无法访问" class="headerlink" title="3. nginx 配置正确，正常启动，但是在远程访问ip地址， 依旧无法访问"></a>3. nginx 配置正确，正常启动，但是在远程访问ip地址， 依旧无法访问</h5><p>在nginx 配置正确，正常启动后，依旧有一个新手在使用阿里云服务器时会遇到的坑。<br>原来，阿里云服务器默认关闭了所有的端口。<br><img src="https://img-blog.csdn.net/20180406185511671?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NsYXJrX0ZpdHo4MTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>在这个管理界面里，在更多选项里，有一个安全组配置，按照提示将相应的端口加入安全组配置中。 之后就可以正常访问ip的相应端口了。</p>
<p>####4.uwsgi 的相关配置<br>uwsgi 的配置全程只需要两个配置文件。<br>一个是  uwsgi_params ，这个文件要放在自己的python项目的根目录下。<br>这个文件的内容是完全固定的，用于nginx 和 uwsgi 之间的请求格式的转换。<br>文件的内容我是从 <a href="http://uwsgi-docs-cn.readthedocs.io/zh_CN/latest/Nginx.html" target="_blank" rel="noopener">uwsgi文档</a> 复制过来的。<br>uwsgi_params的内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi_param QUERY_STRING $query_string;</span><br><span class="line">uwsgi_param REQUEST_METHOD $request_method;</span><br><span class="line">uwsgi_param CONTENT_TYPE $content_type;</span><br><span class="line">uwsgi_param CONTENT_LENGTH $content_length;</span><br><span class="line">uwsgi_param REQUEST_URI $request_uri;</span><br><span class="line">uwsgi_param PATH_INFO $document_uri;</span><br><span class="line">uwsgi_param DOCUMENT_ROOT $document_root;</span><br><span class="line">uwsgi_param SERVER_PROTOCOL $server_protocol;</span><br><span class="line">uwsgi_param REMOTE_ADDR $remote_addr;</span><br><span class="line">uwsgi_param REMOTE_PORT $remote_port;</span><br><span class="line">uwsgi_param SERVER_ADDR $server_addr;</span><br><span class="line">uwsgi_param SERVER_PORT $server_port;</span><br><span class="line">uwsgi_param SERVER_NAME $server_name;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>另一个文件是 uwsgi服务器的主要配置，这个文件的存放位置以及文件的名字随意，因为在启动uwsgi时需要在启动命令中指定该配置文件的绝对位置以及文件名字。<br>以我的配置文件为例，我放在了 /etc/uwsgi/sites/  文件夹下，名叫 uwsgi.ini<br>以下是我的配置文件，<font color="red">内容仅供参考，请结合自己的实际项目来配置</font><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">pidfile = /var/run/uwsgi.pid # 存储uwsgi运行的pid值的文件</span><br><span class="line">daemonize = /home/myproject/myproject.log  # 存储运行的日志文件， myproject 是我的项目文件夹</span><br><span class="line"></span><br><span class="line">chdir = /home/myproject/  # 项目文件夹的位置</span><br><span class="line">module = myproject.wsgi:application</span><br><span class="line"></span><br><span class="line">master = true # 指定启动主进程</span><br><span class="line">chmod-socket = 664  # 运行时的权限</span><br><span class="line">processes = 5  # 设置工作进程的数量</span><br><span class="line">socket = /home/myproject/myproject.sock  # socket文件的位置，运行时自动生成</span><br><span class="line">vacuum = true # 当服务器退出时自动删除unix socket文件和pid文件</span><br></pre></td></tr></table></figure></p>
<p>还有一些常见的配置在<a href="https://henulwj.github.io/2016/04/20/uwsgi-common-use-parameters/" target="_blank" rel="noopener">这篇文章</a>里有详细介绍。</p>
<hr>
<p>关于uwsgi踩过的更多坑，请移步<a href>nginx+uwsgi部署实践的踩坑总结（二）</a></p>
]]></content>
  </entry>
  <entry>
    <title>nginx+uwsgi部署实践的踩坑总结（二）</title>
    <url>/blogs/ck50y9mlh0009y12westvksbt/</url>
    <content><![CDATA[<p>承接上一篇 <a href="https://blog.csdn.net/Clark_Fitz817/article/details/79788043" target="_blank" rel="noopener">nginx+uwsgi部署实践的踩坑总结（一）</a><br>这篇中将继续罗列我在配置nginx+uwsgi中踩过的坑。<br>如果在这篇中没有找到的问题可以去前一篇中查看。</p>
<p>####1.一段非常常见的nginx报错<br>在启动nginx后，查看日志，会看到这么一段报错<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[error] 1198#1198: *224 connect() to unix:///home/myproject/myproject.sock failed (111: Connection refused) while connecting to upstream, client: 37.102.213.142, server: 37.102.213.142, request: &quot;GET /common/page_contents/ HTTP/1.0&quot;, upstream: &quot;uwsgi://unix:///home/myproject/myproject.sock:&quot;, host: &quot;37.102.213.142:8000&quot;, referrer: &quot;http://37.102.213.142/main&quot;</span><br></pre></td></tr></table></figure></p>
<p>我在google上直接搜索这段报错，得到了各种各样的原因分析和解决方案。<br>从报错信息来看，错因是nginx 向uwsgi转发请求，然后这个请求被uwsgi拒绝。<br>基本上，错误的原因不在于nginx， 而在于uwsgi服务器内部发生了错误，导致转发的请求被拒绝。<br>所以，应该去检查uwsgi的日志。<br>检查uwsgi的日志，发现是python有了一段报错，就这样发现了另一个坑，这个坑如下。</p>
<h4 id="2-python-ImportError-No-module-named-‘encodings’"><a href="#2-python-ImportError-No-module-named-‘encodings’" class="headerlink" title="2. python ImportError : No module named ‘encodings’"></a>2. python ImportError : No module named ‘encodings’</h4><p>正如标题，完整的报错如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fatal Python error: Py_Initialize: Unable to get the locale encoding</span><br><span class="line">ImportError: No module named &apos;encodings&apos;</span><br></pre></td></tr></table></figure></p>
<p>经过查找大量的资料，出现这个报错的原因大部分都是由于 python的虚拟运行环境配置错误。<br>python虚拟运行环境又是什么？<br>在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.6。所有第三方的包都会被pip安装到Python3的site-packages目录下。<br>如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要django 1.11.9，而应用B需要django 2.1怎么办？<br>这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</p>
<p>但是我并没有使用python 虚拟运行环境，为什么还会报错？ 后来，发现在 uwsgi的 .ini配置文件中有 home = …    这一项，用于指定虚拟环境变量随意，而我的这一项在配置时不懂，随意填了个值，导致了麻烦的错误。<br>对于单python应用，或者没有使用python 虚拟运行环境，uwsgi 中的home 这一项就不用再赋值了。</p>
<h4 id="3-no-python-application-found-的报错"><a href="#3-no-python-application-found-的报错" class="headerlink" title="3.no python  application found 的报错"></a>3.no python  application found 的报错</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unable to load app 0 (mountpoint=&apos;&apos;) (callable not found or import error)</span><br><span class="line">--- no python application found, check your startup logs for errors ---</span><br></pre></td></tr></table></figure>
<p>这个也是一个比较常见的错误, 错因一般是 某个module或者app 没有 __init__.py这个文件，导致Python无法识别这个应用或模块。只要添加添加上，就不会报错。<br>如果__init__.py这个文件的内容为空，需要用touch 命令去创建这个空文件。<br>__init__.py这个文件作用是对一个python应用或模块进行初始化操作的，道理可以理解为一个类的构造函数，构造函数可以为空，但是一个类不能没有构造函数。</p>
<h4 id="4-Error-That-IP-address-can’t-be-assigned-to"><a href="#4-Error-That-IP-address-can’t-be-assigned-to" class="headerlink" title="4.Error: That IP address can’t be assigned-to."></a>4.Error: That IP address can’t be assigned-to.</h4><p>这个是在使用django 时，输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver http://192.168.1.XX:8080/</span><br></pre></td></tr></table></figure></p>
<p>时，报的错误<br>stack overflow 上给出的解决方案是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver  0:8000</span><br></pre></td></tr></table></figure></p>
<p>亲测真的有效。</p>
<hr>
<p>踩完这些坑后，我的nginx和uwsgi 都可以完美运行了，希望这些分享可以对广大读者和将来某一天 好了伤疤忘了疼的自己 一些帮助。</p>
]]></content>
  </entry>
  <entry>
    <title>分享便捷的编辑器快捷键配置</title>
    <url>/blogs/ck50y9mll000cy12w6rlo66lj/</url>
    <content><![CDATA[<p>作为一个写代码已经两年的码农，我在编辑器快捷配置方面有一些自己的小心得，现在我就分享出来，希望能够提高大家的代码编写速度。<br>我们在写代码时，经常需要用到 ↑↓←→ home(将光标换到一行代码的开头) end(将光标换到一行代码的结尾)这些键，但是这些键距离主要的26英文主键太远，每次需要调整光标位置时，右手就需要离开正常的键位，非常不顺手，写代码就没有了流畅性。<br>还好，大部分编辑器提供了自定义组合按键的功能。我们可以通过将比较近的按键组合，替代<br> ↑↓←→ home end的功能。</p>
<p> <font color="red">下面分享我自己的按键配置：</font><br>左面是自定义的组合按键，右面是替代的功能<br>ALT + I   -&gt;    ↑<br>ALT + K -&gt;     ↓<br>ALT + J -&gt;     ←<br>ALT + L -&gt;     →</p>
<p>ALT + A-&gt;     HOME<br>ALT + D-&gt;     END</p>
<p>Shift + ALT + I   -&gt;    Shift + ↑<br>Shift + ALT + K -&gt;     Shift + ↓<br>Shift + ALT + J -&gt;     Shift + ←<br>Shift + ALT + L -&gt;     Shift + →<br>Shift + ALT + A-&gt;     Shift + HOME<br>Shift + ALT + D-&gt;     Shift +  END</p>
<p>这些组合我是经过长时间摸索的，设计有以下的考虑因素：<br>ALT 这个键的默认组合功能不太多，修改组合功能对原有的功能影响不大，而且距离左手大拇指的位置比较近。<br>J I L K 这四个键的选择主要是基于盲打时右手的初始放置位置，右手在调整光标位置时就不需要变动位置。</p>
<p>可能这些按键在刚开始使用时会各种不适应，也许很多人就放弃了，但是大约只需要坚持使用一星期，就会深深的爱上这些快捷键，因为它们实在太方便顺手了。</p>
<p>题外话：<br>我现在编程的IDE基本都使用 JetBrain 的IDE全家桶了，自从第一次用了pycharm后，就再也离不开这个系列了，功能异常强大，界面美观，可定制化程度高，可能是地表最强IDE了。<br>VScode这款编辑器现在使用越来越广泛，得到了大家的好评，也被称为MicroSoft 唯一良心的软件了。VScode的编辑功能，UI的美观程度，可定制化程度都可以和JetBrain系列相媲美了。</p>
<p>ps:<br>JetBrain系列IDE 的按键配置在 File-&gt;Settings-&gt;KeyMap下，可以通过按键来搜索相应的配置项位置，比较容易修改。<br>Vscode 的按键配置 在 文件-&gt;首选项-&gt;键盘快捷方式 里面，这个需要修改keybindind.json文件，比JetBrain的麻烦一些。</p>
]]></content>
  </entry>
  <entry>
    <title>nginx: [emerg] socket() [::]:80 failed (97: Address family not supported by protocol)报错解决记录</title>
    <url>/blogs/ck50y9mln000dy12w6egfi5fx/</url>
    <content><![CDATA[<p><font color="red">问题描述</font>： </p>
<p>今天我在阿里云服务器上配置 nginx ，刚安装好nginx<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure></p>
<hr>
<p> 使用默认配置，运行<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx # 启动nginx</span><br></pre></td></tr></table></figure></p>
<p>报错如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx: [emerg] socket() [::]:80 failed (97: Address family not supported by protocol)</span><br></pre></td></tr></table></figure></p>
<hr>
<p>然后我运行<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx -t  # 检查nginx的配置是否正确</span><br></pre></td></tr></table></figure></p>
<p>报错如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx: [emerg] socket() [::]:80 failed (97: Address family not supported by protocol)</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test failed</span><br></pre></td></tr></table></figure></p>
<hr>
<p>系统信息：<br>OS: Debian 9.2 stretch<br> Kernel: x86_64 Linux 4.9.0-4-amd64</p>
<hr>
<p><br></p>
<p><font color="red">问题分析</font><br>在 /etc/nginx/sites-enabled/default   文件中，有<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	listen 80 default_server;</span><br><span class="line">	listen [::]:80 default_server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中  listen [::]:80 default_server; 这句是配置对 ipv6端口的监听。<br>ipv4和ipv6有什么区别呢？</p>
<blockquote>
<p>TCP/IP协议是互联网发展的基石，其中IP是网络层协议，规范互联网中分组信息的交换和选路。目前采用的IPv4协议地址长度为32位，总数约43亿个IPv4地址已分配殆尽。<br>IPv6是IP地址的第六版协议，诞生于1999年，其最大的优点就是设计地址长度达128bit，可以提供2的128次方个IP地址，即使将地球上所有沙子都变成晶体管，依然会有足够的IP地址给电子设备使用。<br>近乎无穷的IP地址让IPv6能容得下海量设备，这将与5G等技术一起，支撑移动互联网、物联网、工业互联网、云计算、大数据、人工智能等新兴业态的快速发展。<br>ipv4和ipv6只是位数不同，版本不同，ipv6目前还没有普及。</p>
</blockquote>
<p>目前国内很多服务器不支持ipv6,阿里云现在开始支持ipv6了，但是需要手动开启。<br>因为没有开启ipv6,所以会出现  Address family not supported by protocol  的报错。<br><br></p>
<p><font color="red">解决问题：</font><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure></p>
<p>将 listen [::]:80 default_server; 注释掉<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	listen 80 default_server;</span><br><span class="line">	# listen [::]:80 default_server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx -t  # 检查nginx的配置是否正确</span><br><span class="line"></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure></p>
<p>这样nginx就可以正常启动了。或者还可以将服务器的ipv6开启，具体的方法百度一下挺多的。</p>
]]></content>
  </entry>
  <entry>
    <title>浅谈自己知道的首屏加载时间的优化策略</title>
    <url>/blogs/ck50y9mlo000gy12wmu4g8aui/</url>
    <content><![CDATA[<p>最近我在使用vue全家桶开发一个移动端的页面，经过一个半月项目接近完工，处于优化的阶段。<br>用过前端框架的都知道，spa(单页面应用)的一个最大的缺点就是首屏的加载时间比较长。<br>缩小首屏载时间是一个重要的优化项，总结来主要有以下几种方式：<br><a href="#1">1、尽可能的缩小webpack或者其他打包工具生成的包的大小</a><br><a href="#2">2、使用服务端渲染的方式</a><br><a href="#3">3、使用预渲染的方式</a><br><a href="#4">4、使用gzip减小网络传输的流量大小</a><br><a href="#5">5、按照页面或者组件分块懒加载</a></p>
<h5 id="1">缩小webpack或者其他打包工具生成的包的大小</h5>

<p>为了做到这一点，需要做到尽可能的减少生产环境下依赖的库数量，尽可能的按需引用，减少无用代码占的空间。<br>我刚开始优化的时候，就不知道从何处优化起，而且根本不知道生成的包中哪个依赖占据着空间，我还一度挨个删去库引用，来看哪个库占用的空间最多。 后来才知道有名叫：webpack-bundle-analyzer的分析工具，接下来我顺带总结一下这个包的使用姿势。<br>: 首先</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>
<p>然后在webpack.prod.conf.js中配置：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line">plugins: [</span><br><span class="line"><span class="keyword">new</span> BundleAnalyzerPlugin(</span><br><span class="line">     &#123;</span><br><span class="line">          analyzerMode: <span class="string">'server'</span>,</span><br><span class="line">          analyzerHost: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">          analyzerPort: <span class="number">8888</span>, <span class="comment">// 运行后的端口号</span></span><br><span class="line">          reportFilename: <span class="string">'report.html'</span>,</span><br><span class="line">          defaultSizes: <span class="string">'parsed'</span>,</span><br><span class="line">          openAnalyzer: <span class="literal">true</span>,</span><br><span class="line">          generateStatsFile: <span class="literal">false</span>,</span><br><span class="line">          statsFilename: <span class="string">'stats.json'</span>,</span><br><span class="line">          statsOptions: <span class="literal">null</span>,</span><br><span class="line">          logLevel: <span class="string">'info'</span></span><br><span class="line">        &#125;</span><br><span class="line">     ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>配置就完成了，正常npm run build 结束后，就会自动打开一个打包生成文件的模块组成图在默认浏览器中，图中面积大的就是占据空间大的模块。<br><img src="//img-blog.csdn.net/20180313221254837?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L0NsYXJrX0ZpdHo4MTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>例如上图中，我打包后vue模块占据的空间最大，可以根据这张图去做优化，不会再感到优化无从下手了。</p>
<p>另外再记录一个我在使用element-ui时遇到的包过大的坑，如果在开发时，将element-ui全局引入，打包后的vendor包大小至少700kb以上，相当庞大，然后我就进行了局部应用。<br>我的main.js文件局部代码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  Autocomplete,</span><br><span class="line">  Checkbox</span><br><span class="line">  ……</span><br><span class="line">&#125; from &apos;element-ui&apos;</span><br><span class="line">Vue.use(Autocomplete);</span><br><span class="line">Vue.use(Checkbox);</span><br></pre></td></tr></table></figure></p>
<p>结果打包后包大小没有发生任何变化，一直找不到问题。后来发现官方文档上还需要安装babel-plugin-component插件才能使局部引用有效，以后看文档一定要细心才行。</p>
<h5 id="2">使用服务端渲染的方式</h5>

<p>这个服务端渲染不同于后端渲染，服务端渲染只是把当前的前端框架中的一部分js代码放到服务器上渲染，加载到浏览器上的html就不是一个空页面，这样可以减少首页的白屏时间，同时提高被搜索引擎检索的机会。<br>但是这个服务端渲染有不少的局限，例如它的服务端必须依靠node服务器，不进行服务端渲染方式的只需要一个普通的静态服务器就可以了。还有，vue官方的ssr配置异常的复杂，需要花不少的时间，踩不少的坑,如果开发时使用的vue-cli的话，改用服务端渲染会很麻烦。如果必须要使用服务端渲染的话，最好刚开始就使用基于vue的nuxt.js脚手架去开发，会减去繁琐的配置过程。</p>
<h5 id="3">使用预渲染的方式</h5>

<p>这个预渲染的方式简单来说就是在正常打包时，会预先运行一次js代码，将一部分静态的页面直接渲染成html写在生成的index.html中，这种方式在加载完index.html后，就会有界面展示出来，无需等待加载js代码后再去渲染，所以这种方式也可以显著的减少首屏加载时间，也可以提高被搜索引擎检索的机会，同时预渲染的配置很简单，容易上手。<br>缺点是在需要预渲染的页面较多时，build打包的时间会十分漫长。<br>预渲染的工具有这些：<br><a href="https://github.com/chrisvfritz/prerender-spa-plugin%20prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a><br><a href="https://github.com/stereobooster/react-snap" target="_blank" rel="noopener">react-snap</a><br><a href="https://github.com/errorception/snapshotify" target="_blank" rel="noopener">snapshotify</a><br><a href="https://github.com/egoist/presite" target="_blank" rel="noopener">presite</a></p>
<p><a href="https://github.com/stereobooster/react-snap/blob/master/doc/alternatives.md" target="_blank" rel="noopener">这里还有这几个预渲染插件的各种比较</a></p>
<p>我比较喜欢预渲染这种优化方式，很简单有效，几乎不需要什么配置。这几种插件的基本原理都是本地运行指定的js代码，然后将空头浏览器渲染出的页面写入指定的h5文件。<br>但是我自己在做项目的时候，出现了各种各样的问题。在打包时报出各种各样的错误，解决了一个又出一个，把这几个插件都试了一遍，依然没有成功预编译出一个满意的页面效果，当然这是我个人的问题，与这几个轮子没有关系。</p>
<p>最后，我想出了一种“土”办法，就用自己的浏览器去预渲染页面。<br>在浏览器上打开需要预渲染的页面，然后点击右键选择另存为，将文件保存下来，就得到了“预渲染”的html文件。<br>如果觉得里面的css代码量太大，推荐使用chrome的一个插件 css used, 下载安装之后，在开发者工具中的element中，与style选项并排的就有一个css used选项，点击后就会加载出这个页面用到的css界面，过滤掉了没有用到的css代码，将有用的css代码替换掉原本html里面的css代码即可。<br>最后，需要将打包生成的js和css代码的路径添加到html里面（就像打包生成的index.html一样），这样，在这个html加载完成后，就可以显示一个预渲染的页面了，等到依赖的js和css加载完成后，会有新的代码覆盖掉预渲染的页面。<br>我的这种“土”办法实属无奈，但依旧有效，成功的将首屏加载时间缩短了50%。用这种方法也可以自己制作一个骨架预渲染界面，在等待加载js和css时，界面上只显示一个页面的大体框架，比全白屏的交互体验要好的多。</p>
<h5 id="4">使用gzip减小网络传输的流量大小</h5>

<p>gzip是GNUzip的缩写，最早用于UNIX系统的文件压缩。HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip。目前主流的浏览器，Chrome,firefox,IE等都支持该协议。常见的服务器如Apache，Nginx，IIS同样支持gzip。使用gzip可以将原静态文件压缩到30%，效果很明显，对于优化首屏加载时间非常适合。<br>这种优化实现特别简单，只需要配置一下自己使用的服务器就可以了。<br>以我使用的nginx服务器的配置为例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    proxy_buffering on;</span><br><span class="line">    # 开启gzip</span><br><span class="line">	gzip on;</span><br><span class="line">	# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span><br><span class="line">	gzip_min_length 1k;</span><br><span class="line">	# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间</span><br><span class="line">	gzip_comp_level 2;</span><br><span class="line">	# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span><br><span class="line">	gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class="line">	# 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class="line">	gzip_vary on;</span><br><span class="line">	# 禁用IE 6 gzip</span><br><span class="line">	gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line">	server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location /&#123;</span><br><span class="line">            alias /;</span><br><span class="line">            proxy_connect_timeout 1; </span><br><span class="line">            proxy_send_timeout 30; </span><br><span class="line">            proxy_read_timeout 60;</span><br><span class="line">            # 这里反向代理到本地的开发服务器上</span><br><span class="line">            proxy_pass http://localhost:8080/;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就开启了gzip。</p>
<h5 id="5">按照页面或者组件分块懒加载</h5>

<p>这种优化，就是将每个组件的js代码独立出来，在使用到这个组件时，才向服务器请求文件，并且请求过一次后就会缓存下来，再次使用到这个组件时，就会使用缓存，不再发送请求。<br>配置很简单，只需要在vue-router中添加一些简单的配置即可。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  linkActiveClass: <span class="string">'router-link-active'</span>,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      <span class="comment">// 这里只需要把原来从外部引入的组件换成以下的语句就可以了</span></span><br><span class="line">      component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'../components/(你的组件)'</span>], resolve)</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>其他地方不需要进行任何修改，打包后就会发现js文件数量比原来不分块加载的多了不少。</p>
<p>以上就是我知道或者用过的针对单页面应用的首屏加载时间优化方法，如果还有别的方法，欢迎指出和讨论。 </p>
<h6 id="写作和分享不易，我只求一个赞"><a href="#写作和分享不易，我只求一个赞" class="headerlink" title="写作和分享不易，我只求一个赞~"></a>写作和分享不易，我只求一个赞~</h6>]]></content>
  </entry>
  <entry>
    <title>2018年终总结</title>
    <url>/blogs/ck50y9ml20000y12weu645p26/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><blockquote>
<p>已经20多岁了,却还是第一次写年终总结。最终选择在2018年的最后几个小时里,完成这人生中的第一次年终总结,希望能总结这一年的得失,总结经验和教训,提出新年的目标。</p>
</blockquote>
<h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾:"></a>回顾:</h4><h5 id="学习"><a href="#学习" class="headerlink" title="学习:"></a>学习:</h5><p>目前我还是大三,学习对于学生来说还是第一位的,我就先来回顾学习吧。过去一年的在校成绩方面,和大一大二差不多,平均分80多,没有挂科,每个课学的没有精通,但掌握80%还是有的。但是从目前来看,保研是没有希望了,我的学分绩在50%左右,剩下的半年估计也不会有什么变化了。</p>
<h6 id="得"><a href="#得" class="headerlink" title="得:"></a>得:</h6><p><strong>2018年,我人生中第一次挣到了钱</strong><br>在年初我和室友两个人一起接了一个外包项目,是做一个教育网站,我负责web前端部分的工作,室友负责web后端的工作。我们从寒假开始,一直忙到了四月份才算完工,期间对项目很是上心,也付出了相当多的时间和精力,最终项目还算顺利的完工了,得到了每人8000元的薪酬,混吃混喝20年第一次自己挣到了钱,心里也是很开心和满足的。<br>在这次项目中,我自学了前端框架VUE,写了将近10000行代码,也是自己目前写过的最大的一个项目。从中我得到了项目的实战经验,锻炼了自学的能力,初步体验了和他人协作开发项目的经验。<br>我拿8000元薪酬买了一个微单相机(索尼A7M2),开始入坑摄影了,也算是培养了一个新的兴趣爱好。</p>
<p><strong>2018年,我有了第一个自己的开源项目</strong><br>在暑假里,我又和室友一起开发了一个Chrome的扩展,叫EdgeTranslate(侧边翻译),主要功能是在浏览器中划词翻译,将谷歌翻译的结果直接展示在侧边栏中,主要是为阅读英语资料和论文设计的。这个项目来源于我和室友在完成一个课的论文报告时,当时就遇到了一个麻烦的地方: 每次遇到生词都要先复制到谷歌翻译的页面,看完翻译结果后还要再回到论文的页面,很是浪费时间,当时找了一些浏览器插件,感觉也都不好用,于是当时和室友一商量,就决定在暑假一起开发一个翻译插件,当时真的是一拍即合。<br>在暑假里,我们两个在家里远程交流,协作配合。从刚开始只有20行代码的原型到现在的20000行代码的完善软件,也是在其中付出了不少心血的。<br>开发完后,我将扩展发布到了Chrome应用商店,室友将应用发布到了Firefox应用商店。室友在酷安(一个安卓应用商店)进行了一波宣传,很快就有了一百多个初始用户,也收到了不少肯定和建议,到现在Chrome已经有1.2K+的用户了,Firefox上也有800个用户了,受欢迎程度超过了我们的预期。我在刚发布应用的时候,和室友立了一个flag:如果用户量超过100个,我们就一直把项目维护下去,现在看来,我们达到了目标的20倍。<br>我的github账号开始有人关注了,有了一个略微有影响力的代表项目,在开源开发的道路上开始起步了。希望我以后的闲暇时间里,能使扩展变得更好用,能得到更多人的认可。我要开始学习产品的知识了,学会设计产品的功能,如何提升用户的体验,培养自己的产品思维。</p>
<p><strong>2018年,我第一次开始写博客</strong><br>受张哥的影响,我开始写博客了。在寒假里,我注册了CSDN账号,刚好寒假里要完成外包项目,从那时开始,我就把项目中踩过的坑记录到了博客里,一年下来,博客写了23篇,全是自己的原创,总浏览次数达到了27k。后来,我真的体会到了写博客的好处:我后来在做项目时,会重复遇到之前踩过的坑,但是时间久了又想不起脱坑的细节,这时候翻出自己写过的内容就能极大节约时间了,除此之外,写作也是一项很重要的技能,能把自己的问题和解决方案让别人看懂就是一种能力。<br>希望在之后的时间里,我能把写博客坚持下来,最好能开通自己的公众号。</p>
<p><strong>2018年,我大学第一次得奖</strong><br>今年我参加了一些竞赛,首先是蓝桥杯软件比赛,我得了一个省三等奖(签到奖),之后和其他学院的同学组队,参加了东北数学建模联赛和全国大学生数学建模竞赛,都得了省一等奖,虽然奖项一般般,但也弥补了大学的一块空白,还是一段挺难忘的经历。<br>在两次数学建模竞赛里,我都是负责的编程任务,尤其是在国赛的三天三夜里,我们三个一起喝红牛熬夜建模的经历,感觉很是珍贵。在比赛中,我不仅的了奖项,也获得了两个非常靠谱的队友,这两个队友非常值得珍惜和相处。</p>
<h6 id="失"><a href="#失" class="headerlink" title="失:"></a>失:</h6><p><strong>大学的迷茫期</strong><br>在今年上半年,我度过了大学中最迷茫的一段时间。在刚开学时还能忙于项目,有个目标,但是当项目完成之后,就突然没了目标,开始了一段迷茫期。<br>因为我不知道大学应该朝哪个方向前进了,在保研没了希望后,一时间不想学习了,因为平时成绩除了保研和留学之外就没有用了,而且开始怀疑学习了一年之久的web技术,纠结将来要不要从事这个方向,不确定这个方向是否有前途,在这一年最火的是人工智能和区块链,web技术已经很成熟和饱和了,不确定自己是否有必要继续钻研下去,于是在技术和学习上都停滞了。在春季学期剩下的时间里,我开始经常玩游戏,不太管学习和成绩了,于是上半学期成绩非常惨,处于勉强及格的状态。</p>
<p><strong>错失一次比赛</strong><br>也是在上学期,微信第一次举办小程序竞赛,而web正是我和室友的长处,于是我组织了三人的小队,我是队长,我们的构思和设计都已经初步成型了,就在比赛提交的时间里,一门软件构造课的实验任务量特别巨大,我们三个人都抽不出时间来完成项目,于是就这样弃赛了,感觉很是可惜。因为我们构思的创意出现在了决赛的作品中,感觉我们要是能顺利做出来的话,以我们的项目经验和技术水平,是很有可能能入围决赛的。这又让我想起我在高三那年,参加了物理竞赛,过了初赛后,感觉没有希望能拿奖,就直接没去决赛,于是非常戏剧的结局出现了,所有和我一起进了决赛的同学,全都拿了奖。。。 以后真的每一个机会都得要抓住才行,绝对不能再出现这种主动放弃的行为了。</p>
<p><strong>2018年,我依然单身</strong><br>这一年里,我的交际圈更窄了,很少参加活动,也没花心思在脱单上,唉。。。</p>
<h4 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h4><p>在暑假里,我做出了重大决定,结束了迷茫期。我决定大三要准备考托福,大四申请香港或者美国的研究生了。<br>做出这一决定,我觉得有几个方面的影响因素:<br>其实我爸爸一直就支持和推荐我去国外上大学和读研的, 不得不佩服我爸的思想和见识,但我一直英语一般般,对英语没什么兴趣,家庭条件也不富裕,一直没考虑过这事<br>但是在大二暑假的这个考虑大学出路的时期,我发现自己保研没希望了,同时父母也希望自己继续读研,自己也觉得要读研,这样就只能考研或申请出国了。同样需要学英语,同样需要努力学习,我觉得出国和考研比起来,难度其实差不多。<br>然后就是在暑假回家的火车上,我遇到了一个年纪五六十岁的阿姨,同她交谈了一上午, 感觉她同我见过的同样年纪的人大有不同。这位阿姨在退休之后开始国外旅行,去了许多的国家,感觉她的见识真的不一般,一上午大部分交谈都是在听她讲自己的经历,很是羡慕和佩服, 我开始希望自己将来也能有这样的经历,有机会去亲眼见见国外的世界,体会其他国家的文化和习俗。<br>于是我开始初步了解留学事宜, 发现香港和英国的研究生只需要一年时间,而且香港只需要英语语言成绩证明的硬性条件,花费一年二三十万,但是我可以早毕业工作一年,这样和国内读研相比,差不多的花费,还能多一年的工作经验,感觉很是划算,同时还能逼迫我把英语水平提上来,英语的重要性已经得到大部分人的认同了。美国的大学也很受中国企业的认可,能申请到前50名的大学就很值得去读了。<br>经历过这些之后,我开始解放自己的思想了,决定好了大三的目标,也开始放眼世界,了解更多国外的情况。<br>我开始意识到自己成长环境和家庭教育的不足:自己从小生活的环境是一个五线小城市,教育比较落后,父母虽然比较有文化,但是和高中大学的同学的父母比较起来,差距还真是不小,同时,我开始认识到自己性格(比较内向)和思维上的缺陷(缺乏想象力),开始了解英联邦的教育制度,了解欧美的生活方式,思维习惯。感觉欧美的教育制度真的比国内目前的应试教育制度更加科学,更能培养人的创新能力和表达能力。自己的成长环境不能由我自己决定,但是我可能争取改变自己后代的成长教育环境,就要通过我自己的努力来实现了。首先我要解放自己的思想,提升的自己的认知水平,然后要有足够的经济水平来负担起这样的教育支出。</p>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望:"></a>展望:</h4><p>新年的目标: </p>
<ul>
<li>托福考上95分以上</li>
<li>提升GPA, 争取竞赛(美赛和蓝桥杯)能多得些奖</li>
<li>申请到香港或美国不错的大学的研究生</li>
<li>如果申请顺利,希望大四能获得企业实习机会</li>
</ul>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语:"></a>结语:</h4><p>回望自己的2018年,收获不少,也经历了一段时间的迷茫,所幸的是,自己终于在2019年有了几个非常明确的努力目标,规划出了一个满意的人生发展轨迹。<br>2019年辛苦一年,我就能获得之后几年比较安逸的生活了。<br>加油! 2019年, 就是干!</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>感悟</tag>
        <tag>年终总结</tag>
      </tags>
  </entry>
</search>
